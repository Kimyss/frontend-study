<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 내장객체 (JS기본제공)
    // 자바스크립트 엔진에 내장되어 필요한 경우 생성하여 사용
    // Object 객체는 모든 JS객체의 최상위(루트) 객체
    // 그 외에도 String, Number, Date, Array, Math등 다양한 객체가 존재

    // 1.String 객체
    // 문자열을 다루기 위한 객체로 문자열을 다룰 때 유용한 속성과 함수를 제공
    // 문자열 생성 2가지 방식
    // 변수 = new String('문자');
    // 변수 = '문자'; => 리터럴방식
    document.write('<h1>String 객체</h2>');

    // 1) length
    // 문자열 길이를 반환하는 속성
    document.write('<h4>문자열 길이</h4>');
    const txt = 'ABCDEFGHIJKLMNOPQRSUVWXYZ';
    const sin = txt.length;
    document.write(sin, '<br>');

    // 2)indexOf() 인덱스오브 함수!
    // 문자열안에 특정 문자열이 존재하는지 찾고, 
    // 있다면 찾고자 하는 문자열이 시작되는 index를 반환(처음 나타나는 위치)
    // 발견하지 못하면 -1을 반환
    document.write('<h4>문자열검색</h4>');
    let str = 'Please locate where "locate" occurs!';
    let pos = str.indexOf('locate');
    document.write(pos, '<br>');
    // '010-1111-1234'.indexOf('-1');

    // 3)lastIndexOf()
    // 문자열안에 특정 문자열이 존재하는지 찾고, (indexOf 동일)
    // 찾고자 하는 문자열이 둘 이상 발견되면 제일 마지막에 발견된 문자열의 index를 반환
    // (문자열 끝에서부터 검색)
    // 발견하지 못하면 -1을 반환
    pos = str.lastIndexOf('locate');
    document.write(pos, '<br>');

    // 검색 시작 위치(index) 지정 가능
    pos = str.indexOf('locate', 15); //어쨋든 앞에서 시작
    document.write(pos, '<br>');

    pos = str.lastIndexOf('lacate', 15);  //뒤에서 시작
    document.write(pos, '<br>');
    // (ES6차) includes()
    // 지정된 문자열이 포함된 경우 true를 반환
    // 그렇지 않으면 false를 반환
    pos = str.includes('locate');
    document.write(pos, '<br>');
    pos = str.includes('locate', 15);
    document.write(pos, '<br>');

    // 실습: 사용자로부터 입력받은 이메일 주소 유효성 검사
    // 정규표현식을 안쓰는 경우(실무에서는 정규식 사용!!)
    document.write('<h4>실습: 이메일 주소 유효성 검사</h4>');
    // const userEmail = prompt('당신의 이메일 주소는?');
    // const arrUrl = ['.co.kr', '.com', '.net', '.or.kr', '.go.kr'];

    // let check1 = false;
    // let check2 = false;

    // if (userEmail.indexOf('@') > 0) { // @가 있는지 검사
    //   check1 = true;
    // }

    // for (let i = 0; i < arrUrl.length; i++) {
    //   if (userEmail.indexOf(arrUrl[i]) > 0) { // 도메인 검사
    //     check2 = true;
    //     break;
    //   }
    // }

    // if (check1 && check2) {
    //   document.write(userEmail, '<br>');
    // } else {
    //   alert('이메일 형식이 잘못되었습니다.');
    // }

    // (참고) 정규 표현식(정규식)
    // 문자열에서 특정 문자 조합을 찾기 위한 패턴
    // 주로 회원가입 시 유효성 검사(패스워드, 이메일, 전화번호 포맷 검증 등)에 사용

    // 4) slice()
    // 시작 위치와 종료 위치를 주면, 문자열에서 해당 부분을 잘라내서 반환
    document.write('<h4>문자열 추출</h4>');
    str = 'Apple, Banana, Kiwi';
    let res = str.slice(7, 13);
    document.write(res, '<br>');

    // 두번째 인수인 종료 위치를 생략하면, 시작 위치에서 문자열의 마지막 위치까지 잘라내서 반환
    res = str.slice(7);
    document.write(res, '<br>');

    // 첫번째 인수인 시작 위치를 음수로 주면, 문자열의 끝에서부터 거꾸로 읽게 됨
    res = str.slice(-12);
    document.write(res, '<br>');

    // 5) substring()
    // slice() 함수와 동일한 기능
    // 인수로 음수를 허용하지 않는다는 차이
    res = str.substring(7, 13);
    document.write(res, '<br>');
    res = str.substring(7);
    document.write(res, '<br>');

    // 6) substr()
    // 시작 위치에서 지정한 길이 만큼 잘라내서 반환
    res = str.substr(7, 6);
    document.write(res, '<br>');
    res = str.substr(7);
    document.write(res, '<br>');
    res = str.substr(-12);
    document.write(res, '<br>');

    // 7) replace()
    // 문자열 내의 특정 문자열을 지정한 문자열로 바꾸고 새 문자열을 반환
    // 이때 바꾸려는 문자열이 하나 이상 있더라도 처음 발견된 문자열만 바꾸게 됨
    document.write('<h4>문자열 변환</h4>');
    str = 'Please visit Seoul and Seoul!';
    let n = str.replace('Seoul', 'Jeju');
    document.write(n, '<br>');

    // 대소문자 구분
    n = str.replace('SEOUL', 'Jeju');
    document.write(n, '<br>');

    // 정규 표현식과 함께 사용
    n = str.replace(/SEOUL/i, 'Jeju'); // i=insensitive, 대소문자를 구분하지 않겠다는 뜻
    document.write(n, '<br>');
    n = str.replace(/Seoul/g, 'Jeju'); // g=global, 일치하는 모든 문자열을 찾겠다는 뜻
    document.write(n, '<br>');

    // 8) toUpperCase(), toLowerCase()
    // 문자열을 모두 대문자로 변경
    let text1 = 'Hello World!';
    let text2 = text1.toUpperCase();
    document.write(text2, '<br>');

    // 문자열을 모두 소문자로 변경
    text2 = text1.toLowerCase();
    document.write(text2, '<br>');

    // 실습: 주민등록번호를 입력받은 후 정보가 노출되지 않도록 뒤의 여섯자리는 ******로 출력하세요.
    document.write('<h4>실습: 주민등록번호 마스킹</h4>');
    // const userSsn = prompt('주민등록번호를 입력하세요.');

    // // 123456-1234567 -> 123456-1******
    // const maskSsn = userSsn.substring(0, userSsn.length - 6) + '******';
    // document.write(maskSsn, '<br>');
    // document.write(userSsn.substr(0, 8) + '******', '<br>');

    // 9) concat()
    // 2개 이상의 문자열을 하나의 문자열로 합치고 새 문자열로 반환
    document.write('<h4>문자열 결합</h4>');
    text1 = 'Hello';
    text2 = 'World!';
    let text3 = text1.concat(' ', text2);
    document.write(text3, '<br>');
    let text4 = text1 + ' ' + text2;
    document.write(text4, '<br>');

    // 10) trim
    // 문자열의 앞, 뒤 공백을 모두 제거
    str = '       Hello World!        ';
    console.log(str);
    console.log(str.trim());

    // 11) charAt()
    // 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환
    document.write('<h4>특정 문자 1개 추출</h4>');
    str = 'HELLO WORLD';
    document.write(str.charAt(0), '<br>');

    // 12) charCodeAt()
    // 문자열에서 특정 인덱스에 해당하는 문자 하나의 유니코드 값을 반환
    document.write(str.charCodeAt(0), '<br>');
    document.write('가'.charCodeAt(1), '<br>');

    // 13) split()
    // 특정 구분자를 기준으로 문자열을 분리해서 배열로 반환
    document.write('<h4>문자열 배열로 쪼개기</h4>');
    const birthday = '2022-10-15';
    const arrBirthday = birthday.split('-'); // 하이픈(-)을 기준으로 문자열을 분리
    console.log(arrBirthday);


    // 2. Array 객체
    // 여러 데이터를 순차적으로 저장 가능한 객체로 배열을 다룰 때 유용한 속성과 함수를 제공
    // 배열 객체 생성 3가지 방식

    // 첫번째 방식
    // 변수 = new array(값1, 값2, 값3);

    // 두번째방식
    // 변수 = new Array();
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;

    // 세번째 방식
    // 변수 = [값1, 값2, 값3];    => 리터럴방식

    document.write('<h1>Array 객체</h1>')

    arr = ['Batman', 'Superman', 'Spidernman'];

    // 배열 요소변경
    // 인덱스 index  로 접근하여 새로운 요소를 할당
    arr[0] = 'Xman';
    console.log(arr);

    // 배열 요소 접근

    document.write('<h4>배열값 가져오기-1 </h4>');
    document.write(arr[0], '<br>');
    document.write(arr[1], '<br>');
    document.write(arr[2], '<br>');



    document.write('<h4>배열값 가져오기-2 (for문)</h4>');

    for (let i = 0; i < arr.length; i++) {
      document.write(arr[i], '<br>');
    }


    document.write('<h4>배열값 가져오기-3 (in arr) (권장안함) </h4>');
    for (const i in arr) {      //key값을 가져옴
      document.write(arr[i], '<br>');
    }


    document.write('<h4>배열값 가져오기-4 (for of)</h4>');
    for (const el of arr) {     // value값을 가져온다
      document.write(el, '<br>');
    }

    document.write('<h4>배열값 가져오기-5 (for each)</h4>');
    arr.forEach(function (element, index) {
      document.write(index, ': ', element, '<br>');
    });

    // 배열의 메소드(함수)
    // 1)toString()
    // 배열 안의 모든 요소를 쉼표(,)를 이용해 결합해서 하나의 문자열로 반환
    let fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    console.log(fruits.toString());
    // document.write(fruits.toString()); 
    // document.write({name: 'kim'});

    // 2)join()
    // 배열 안의 모든 요소를 지정한 문자를 이용해 결합해서 하나의 문자열로 반환
    console.log(fruits.join(' 뉴뉴 '));

    // 3)pop()
    // 배열에서 마지막 데이터를 제거하고 그 마지막 데이터를 반환해준다
    // 원본 배열이 변경됨

    let x = fruits.pop();
    console.log(x);
    console.log(fruits);


    // 4)shift()
    // 배열에서 첫번째 데이터를 제거하고 그 첫번째 데이터를 반환해준다
    // 원본 배열이 변경됨

    x = fruits.shift();
    console.log(x);
    console.log(fruits);

    // 5) push()  
    // 배열에 새로운 요소추가, 배열의 길이를 변환
    // 원본 배열이 변경됨

    let ln = fruits.push('Mango');
    console.log(fruits);

    // 6) unshift()
    // 배열의 맨 앞에 새로운 요소추가, 배열의 길이를 변환
    // 원본 배열이 변경됨
    ln = fruits.unshift('Banana');
    console.log(fruits);

    // 7) splice()
    // 새로운 요소를 특정 위치에 추가하거나 기존요소를 삭제할 수도 있음
    // 원본 배열이 변경됨
    // fruits.splice(index, howmany, item1, item2 ... itemX);
    // index : 항목추가하거나 제거할 인덱스번호
    // howmany : 제거할 항목 수
    // 나머지 파라미터 : 추가할 새 요소
    fruits.splice(2, 0, 'Lemon', 'kiwi');
    console.log(fruits);
    fruits.splice(2, 3, 'Grape');   //2번부터 3개 지우고 포도 추가
    console.log(fruits);

    // 8) concat()
    // 2개 이상의 배열을 하나의 배열로 결합
    // 새로운 배열로 반환
    const arr1 = ['cecilki', 'Lon'];
    const arr2 = ['Emil', 'Tobi', 'Ltn'];
    const arr3 = ['Robub', 'Morgan'];
    const myChildren = arr1.concat(arr2, arr3);
    console.log(myChildren);

    // 9)slice()
    // 지정된 시작과 끝 위치(포함되지 않음) 구간만큼 잘라내서 반환
    // 새로운 배열로 반환

    fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
    const citrus = fruits.slice(3);
    console.log(citrus);
    const citrus2 = fruits.slice(1, 3);
    console.log(citrus2);

    // 10)sort()
    // 배열에 문자형 데이터가 있는 경우 오름차순으로 정렬
    // 원본 배열이 변경됨 
    fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    fruits.sort;
    console.log(fruits);

    let kor = ['나', '다', '가', '마', '라'];
    kor.sort();
    console.log(kor);

    // 배열안에 숫자형 데이터가 있더라도 기본적으로는 문자열로 인식해서 오름차순 정렬
    const points = [40, 100, 1, 5, 25, 10];
    points.sort();
    console.log(points);
    // '25' '100' 보다 크다. '2'가 '1'보다 더 크기 때문
    // 그래서 숫자 값으로 정렬하려면 정렬(비교) 함수를 정의해서 사용해야함
    // array.sort(정렬함수);    인자값으로 정렬함수 넣어야함
    // 정렬함수 : function(a, b) {return a - b}
    points.sort(function (a, b) { return a - b });
    console.log(points);
    // 정렬 원리
    // 음수가 나오면 a, b순으로 두요소의위치를 바꾸지않음
    // 양수가 나오면 두 요소의 위치를 바꿈
    // 0이 나오면 변화 없음

    // Quiz 내림차순정렬
    points.sort(function (a, b) { return b - a });
    console.log(points);

    // 활용 Tip     ( data type에 활용 예 참조 (고려은단...) )
    // // Object의 특정 키를 기준으로 sort() 함수를 사용하는 경우가 많음
    // 예: 쇼핑몰 상품 목록에서 가격 높은 순, 낮은 순, 리뷰 많은 순, 누적 판매 순
    // 실습: 아래 사람들을 점수가 높은 순으로 정렬하기
    const persons = [
      {
        name: '유재석',
        point: 78,
        city: '서울',
      },
      {
        name: '김종국',
        point: 92,
        city: '서울',
      },
      {
        name: '양세찬',
        point: 76,
        city: '제주',
      },
      {
        name: '하하',
        point: 81,
        city: '서울',
      },
    ];

    persons.sort(function (a, b) {
      return b.point - a.point;
    });
    console.log(persons);

    // 11) reverse()
    // 배열의 순서를 반대로 바꿈
    // 원본 배열이 변경됨
    // 보통 정렬된 배열을 역순으로 정렬할 때 사용
    fruits = ['Banana', 'Orange', 'Apple', 'Mango'];
    fruits.sort();
    console.log(fruits);
    fruits.reverse();
    console.log(fruits);

    // 12) indexOf(), lastIndexOf()
    // 배열안에 특정 요소가 존재하는지를 찾고,
    // 찾으면 첫번째인덱스(위치)를 반환
    // 찾을 수 없는 경우 -1반환
    fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];
    let index = fruits.indexOf('Apple');
    console.log(index); // 2
    index = fruits.indexOf('Apple', 3); // 검색 시작 위치 지정
    console.log(index); // 4
    index = fruits.lastIndexOf("Apple");
    console.log(index); // 4

    // (ES7차) includes()
    // 지정된 값이 포함된 경우 true를 반환
    // 포함되지 않은 경우 false를 반환
    index = fruits.includes('Mango');
    console.log(index); // true
    index = fruits.includes('Banana', 3); // 검색 시작 위치 지정
    console.log(index); // false


    // 3. Math 객체
    // 수학적인 상수와 내장 함수를 가진 객체로 수학 관련 속성과 함수를 제공
    // 다른 객체와 달리 Math생성자가 아님. (new array | new String)
    // 즉 객체를 생성하지 않고 사용가능  Math()XXXX => 정적(static)
    // Math.속성명;
    // Math.함수명();
    document.write('<h1>Math 객체</h1>');

    // 속성
    document.write('<h4>원주율 PI</h4>');
    document.write(Math.PI, '<br>');

    // 1) Math.round()
    // 숫자에 대한 반올림 처리(소수점 첫째 자리 반올림)
    document.write('<h4>round() 소수첫째반올림</h4>');
    document.write(Math.round(4.9), '<br>');
    document.write(Math.round(4.7), '<br>');
    document.write(Math.round(4.6), '<br>');
    document.write(Math.round(4.5), ' (4.5) <br>');
    document.write(Math.round(4.3), '<br>');
    document.write(Math.round(4.2), '<br>');

    document.write('<br>');

    // 2)Math.ceil()
    // 숫자에 대한 무조건 올림
    document.write('<h4>ceil() 무조건올림</h4>');
    document.write(Math.ceil(4.9), '<br>');
    document.write(Math.ceil(4.7), '<br>');
    document.write(Math.ceil(4.6), '<br>');
    document.write(Math.ceil(4.5), '<br>');
    document.write(Math.ceil(4.3), '<br>');
    document.write(Math.ceil(4.2), '<br>');
    // 예)
    // 50 / 15 = 3.33333333333335, Math.ceil(50 /15) = 4
    // 총 페이지수 = Math.ceil(총아이템수 50 /한 페이지당 보이는 아이템 수 : 15);


    // 3)Math.floor()
    // 숫자에 대한 무조건 내림 처리(소수 첫째 자리 내림)
    document.write('<h4>floor() 무조건내림</h4>');
    document.write(Math.floor(4.9), '<br>');
    document.write(Math.floor(4.7), '<br>');
    document.write(Math.floor(4.6), '<br>');
    document.write(Math.floor(4.5), '<br>');
    document.write(Math.floor(4.3), '<br>');
    document.write(Math.floor(4.2), '<br>');

    // 4)Math.trunc()
    // 소수 부분은 무조건 버리고 정수 부문만 반환
    document.write('<h4>trunc() 소수버리고 정수부분만</h4>');
    document.write(Math.floor(4.9), '<br>');
    document.write(Math.floor(4.7), '<br>');
    document.write(Math.floor(4.6), '<br>');
    document.write(Math.floor(4.5), '<br>');
    document.write(Math.floor(4.3), '<br>');
    document.write(Math.floor(4.2), '<br>');

    // 5) Math.sign()
    // 숫자가 양수인지 음수인지 확인하는 용도로 사용
    // 양수이면 1, 음수이면 -1, 0이면 0을 반환
    document.write('<h4>sign()</h4>');
    document.write(Math.floor(-5), '<br>');
    document.write(Math.floor(0), '<br>');
    document.write(Math.floor(7), '<br>');
    // 잘 안쓰이긴 함 -  비교연산자 (i < 0)~

    // 6)Math.pow
    // 거듭제곱(pow)한 값을 반환
    document.write('<h4>pow(a, b) a의 b제곱 </h4>');
    document.write(Math.pow(8, 2), '<br>');

    // (ES7차) 지수 연산자
    // **은 지수를 뜻함
    document.write('<h5>(ES6차)지수연산자</h5>');
    document.write(8 ** 2, '<br>');
    // 거듭제곱 연산을 여러번 결합할 때 유용
    document.write(Math.pow(Math.pow(2, 2), 2), '<br>');
    document.write(2 ** 2 ** 2, '<br>');

    // 7) Math.sqrt()
    // 제곱근(Square root) 값을 반환
    document.write('<h4>sqrt() 제곱근반환</h4>')
    document.write(Math.sqrt(64), '<br>');  //root64 = 8 

    // 8)Math.abs()
    // 절대값(absoulte)을 반환. 즉 , 무조건 양수로 반환
    document.write('<h4>abs() 절대값 반환 (양수)</h4>');
    document.write(Math.abs(-4, 7), '<br>');

    // 9)Math.min()
    //   Math.Max()
    // 최소값(), 최대값() 반환
    document.write('<h4>max(), min()  최대값, 최소값 반환</h4>');
    document.write(Math.min(0, 150, 30, 20, -8, -200), '<br>');
    document.write(Math.max(0, 150, 30, 20, -8, -200), '<br>');

    // 10)Math.random()
    // 0보다 크거나 같고 1보다 작은 범위에서 숫자형 값을 반환
    // 0.0이상 1.0 미만의 부동 소수점 난수(실수. 소수점값)를 반환
    document.write('<h4>random()</h4>')
    document.write(Math.random(), '<br>');    //랜덤 숫자반환

    // 응용 1에서 10사이의 랜덤한 정수생성
    document.write('<h4>1에서 10 사이의 랜덤한 정수</h4>');
    const randomNum = Math.random();
    // 0.0 <= Math.random() < 1.0
    document.write(randomNum, '<br>');
    // 0.0 <= Math.random() * 10 < 10.0
    document.write(randomNum * 10, '<br>');
    // 0 <= Math.floor(Math.random() * 10) < 10
    document.write(Math.floor(randomNum * 10), '<br>');
    // 1 <= Math.floor(Math.random() * 10) + 1 < 11
    document.write(Math.floor(randomNum * 10) + 1, '<br>');

    // 실제 실무에서 특정 범위의 랜덤 정수값을 생성하는 경우가 많음
    // 공식화 Math.floor(Math.random() *(최대값 - 최소값 + 1)) + 최소값;
    // 자주 쓰면 함수로 만들어 놓기
    document.write('<h4>최소값과 최대값 사이의 정수를 반환하는 함수</h4>')
    function getRandomIntger(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    document.write(getRandomIntger(10, 60), '<br>');

    // 실습 : 가위, 바위, 보 맞추기
    document.write('<h4>가위 바위 보 맞추기</h4>');
    const selecrRps = prompt('가위, 바위, 보 중 선택', '가위');
    let user;

    switch (selecrRps) {
      case '가위':
        user = 1;
        break;
      case '바위':
        user = 2;
        break;
      case '보':
        user = 3;
        break;
      default:
        alert('잘못 작성하셨습니다.');
        location.reload();    //새로고침
        break;
    }

    //1 ~ 3 사이의 랜덤한 정수 생성
    const com = Math.floor(Math.random() * 3) + 1;
    document.write(`<img src="images/Math_img_${com}.jpg">`);

    if (com === user) {
      document.write(`<img src = "images/game_1.jpg">`);
    } else {
      document.write(`<img src = "images/game_2.jpg">`);
    }
    document.write('<br>');

    // Quiz : 가위 바위보 게임만들기
    document.write('<h4>가위 바위 보 게임만들기</h4>');

    document.write('컴퓨터가 낸 것');
    document.write(`<img src="images/math_img_${com}.jpg">`);
    document.write('VS 내가 낸것');
    document.write(`<img src="images/math_img_${user}.jpg">`);

    // 누가 이겼는지 출력
    // user와 com의 차를 이용
    // 0이면 비김
    // 1 또는 -2 이면 내가이김
    // 그 외는 내가짐
    const whoWin = user - com;
    if (whoWin === 0) {
      document.write('비김');
    } else if (whoWin === 1 || whoWin === -2) {
      document.write('이김');
    } else {
      document.write('짐');
    }
    document.write('<br>');


  </script>
</body>

</html>